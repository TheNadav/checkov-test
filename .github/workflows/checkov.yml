name: Checkov IaC Scan

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: read
  security-events: write
  actions: read
  pull-requests: write

jobs:
  checkov-scan:
    name: Checkov Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Checkov
        id: checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: .
          framework: terraform
          soft_fail: false
          quiet: false
          output_format: cli,json,sarif
          output_file_path: console,checkov_results.json,checkov_results.sarif
        continue-on-error: true
        env:
          LOG_LEVEL: DEBUG

      - name: List output files for debugging
        if: always()
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Looking for Checkov results files ==="
          find . -name "*checkov*" -o -name "*.json" -o -name "*.sarif" 2>/dev/null | head -20
          echo "=== Checking for JSON file ==="
          if [ -f "checkov_results.json" ]; then
            echo "Found checkov_results.json"
            head -100 checkov_results.json
          else
            echo "checkov_results.json not found"
          fi
          if [ -f "results.json" ]; then
            echo "Found results.json"
            head -100 results.json
          fi

      - name: Upload SARIF to Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: checkov_results.sarif

      - name: Generate PR Comment
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let checkovResults;
            const possiblePaths = [
              'checkov_results.json',
              'results.json',
              'checkov-results.json',
              'results/results_json.json'
            ];

            let foundFile = false;
            for (const path of possiblePaths) {
              try {
                console.log(`Attempting to read: ${path}`);
                const fileContent = fs.readFileSync(path, 'utf8');
                console.log(`Successfully read ${path} (${fileContent.length} bytes)`);
                console.log('First 500 chars:', fileContent.substring(0, 500));
                checkovResults = JSON.parse(fileContent);
                console.log('Parsed JSON successfully');
                console.log('Structure keys:', Object.keys(checkovResults));
                foundFile = true;
                break;
              } catch (error) {
                console.log(`Failed to read ${path}: ${error.message}`);
              }
            }

            if (!foundFile) {
              console.log('Could not find Checkov JSON results file in any expected location');
              return;
            }

            const summary = checkovResults.summary || {};
            const passed = summary.passed || 0;
            const failed = summary.failed || 0;
            const skipped = summary.skipped || 0;

            let criticalCount = 0;
            let highCount = 0;
            let mediumCount = 0;
            let lowCount = 0;
            let unknownCount = 0;

            const failedChecks = checkovResults.results?.failed_checks || [];

            console.log(`Total failed checks: ${failedChecks.length}`);

            if (failedChecks.length > 0) {
              console.log('=== FULL SAMPLE CHECK STRUCTURE ===');
              console.log(JSON.stringify(failedChecks[0], null, 2));
              console.log('=== CHECKING FOR SEVERITY FIELDS ===');
              console.log('check.severity:', failedChecks[0].severity);
              console.log('check.check_class:', failedChecks[0].check_class);
              console.log('Available fields:', Object.keys(failedChecks[0]));

              console.log('\n=== FIRST 5 CHECKS ===');
              for (let i = 0; i < Math.min(5, failedChecks.length); i++) {
                console.log(`Check ${i}: ${failedChecks[i].check_id}`);
                console.log(`  - severity field: ${failedChecks[i].severity || 'NOT PRESENT'}`);
                console.log(`  - check_class field: ${failedChecks[i].check_class || 'NOT PRESENT'}`);
              }
            }

            const severityMap = {
              'CRITICAL': 'critical',
              'HIGH': 'high',
              'MEDIUM': 'medium',
              'LOW': 'low',
              'INFORMATIONAL': 'low',
              'INFO': 'low',
              'UNKNOWN': 'medium'
            };

            failedChecks.forEach((check, index) => {
              let severity = check.severity || check.check_class || 'UNKNOWN';

              if (typeof severity === 'string') {
                severity = severity.toUpperCase();
              }

              const severityLower = severityMap[severity] || 'medium';

              if (severityLower === 'critical') {
                criticalCount++;
              } else if (severityLower === 'high') {
                highCount++;
              } else if (severityLower === 'medium') {
                mediumCount++;
              } else if (severityLower === 'low') {
                lowCount++;
              } else {
                unknownCount++;
                if (index < 5) {
                  console.log(`Unknown severity for check ${check.check_id}: "${severity}" (original: ${check.severity || 'none'})`);
                }
              }

              check.computed_severity = severityLower;
            });

            console.log(`Severity counts - Critical: ${criticalCount}, High: ${highCount}, Medium: ${mediumCount}, Low: ${lowCount}, Unknown: ${unknownCount}`);

            let comment = `## üõ°Ô∏è Checkov IaC Security Scan Results\n\n`;
            comment += `### Summary\n`;
            comment += `| Status | Count |\n`;
            comment += `|--------|-------|\n`;
            comment += `| ‚úÖ Passed | ${passed} |\n`;
            comment += `| ‚ùå Failed | ${failed} |\n`;
            comment += `| ‚è≠Ô∏è Skipped | ${skipped} |\n\n`;

            comment += `### Findings by Severity\n`;
            comment += `| Severity | Count |\n`;
            comment += `|----------|-------|\n`;
            comment += `| üî¥ Critical | ${criticalCount} |\n`;
            comment += `| üü† High | ${highCount} |\n`;
            comment += `| üü° Medium | ${mediumCount} |\n`;
            comment += `| üü¢ Low | ${lowCount} |\n`;
            if (unknownCount > 0) {
              comment += `| ‚ö™ Unknown | ${unknownCount} |\n`;
            }
            comment += `\n`;

            if (criticalCount > 0 || highCount > 0) {
              comment += `### ‚ö†Ô∏è Critical & High Severity Issues\n\n`;

              const criticalAndHigh = failedChecks
                .filter(check => {
                  const severity = check.computed_severity || '';
                  return severity === 'critical' || severity === 'high';
                })
                .slice(0, 15);

              criticalAndHigh.forEach(check => {
                const severity = check.computed_severity === 'critical' ? 'üî¥ CRITICAL' : 'üü† HIGH';
                comment += `#### ${severity}: ${check.check_id}\n`;
                comment += `**File:** \`${check.file_path}:${check.file_line_range?.[0] || 'N/A'}\`\n`;
                comment += `**Resource:** \`${check.resource}\`\n`;
                comment += `**Description:** ${check.check_name}\n`;
                if (check.guideline) {
                  const shortGuideline = check.guideline.length > 200
                    ? check.guideline.substring(0, 200) + '...'
                    : check.guideline;
                  comment += `**Guideline:** ${shortGuideline}\n`;
                }
                comment += `\n`;
              });

              const criticalHighCount = criticalCount + highCount;
              if (criticalHighCount > 15) {
                comment += `\n_... and ${criticalHighCount - 15} more critical/high severity issues. Check the Security tab for full details._\n\n`;
              }
            }

            if (mediumCount > 0 || lowCount > 0) {
              comment += `### ‚ÑπÔ∏è Medium & Low Severity Issues\n`;
              comment += `Found ${mediumCount} medium and ${lowCount} low severity issues. These won't block the merge but should be reviewed.\n\n`;
            }

            if (criticalCount > 0 || highCount > 0) {
              comment += `\n---\n`;
              comment += `‚ùå **Build Status:** FAILED - ${criticalCount} Critical and ${highCount} High severity issues found!\n`;
              comment += `\nüí° **Next Steps:** Fix the critical and high severity issues above before merging.\n`;
            } else if (failed > 0) {
              comment += `\n---\n`;
              comment += `‚ö†Ô∏è **Build Status:** PASSED with warnings - Only low/medium severity issues found (${mediumCount} medium, ${lowCount} low).\n`;
              comment += `\nüí° Consider fixing these issues to improve security posture.\n`;
            } else {
              comment += `\n---\n`;
              comment += `‚úÖ **Build Status:** PASSED - No security issues found!\n`;
            }

            comment += `\nüìä View detailed results in the [Security tab](https://github.com/${{ github.repository }}/security/code-scanning)`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üõ°Ô∏è Checkov IaC Security Scan Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }