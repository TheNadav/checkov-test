name: Checkov IaC Scan

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: read
  security-events: write
  actions: read
  pull-requests: write

jobs:
  checkov-scan:
    name: Checkov Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Checkov with severity filtering
        id: checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: .
          framework: terraform
          soft_fail: false
          hard_fail_on: HIGH,CRITICAL
          quiet: true
          output_format: cli,json,sarif
          output_file_path: console,checkov_results.json,checkov_results.sarif
        continue-on-error: true

      - name: List output files for debugging
        if: always()
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Looking for Checkov results files ==="
          find . -name "*checkov*" -o -name "*.json" -o -name "*.sarif" 2>/dev/null | head -20
          echo "=== Checking for JSON file ==="
          if [ -f "checkov_results.json" ]; then
            echo "Found checkov_results.json"
            head -100 checkov_results.json
          else
            echo "checkov_results.json not found"
          fi
          if [ -f "results.json" ]; then
            echo "Found results.json"
            head -100 results.json
          fi

      - name: Upload SARIF to Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: checkov_results.sarif

      - name: Generate PR Comment
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let checkovResults;
            const possiblePaths = [
              'checkov_results.json',
              'results.json',
              'checkov-results.json',
              'results/results_json.json'
            ];

            let foundFile = false;
            for (const path of possiblePaths) {
              try {
                console.log(`Attempting to read: ${path}`);
                const fileContent = fs.readFileSync(path, 'utf8');
                console.log(`Successfully read ${path} (${fileContent.length} bytes)`);
                console.log('First 500 chars:', fileContent.substring(0, 500));
                checkovResults = JSON.parse(fileContent);
                console.log('Parsed JSON successfully');
                console.log('Structure keys:', Object.keys(checkovResults));
                foundFile = true;
                break;
              } catch (error) {
                console.log(`Failed to read ${path}: ${error.message}`);
              }
            }

            if (!foundFile) {
              console.log('Could not find Checkov JSON results file in any expected location');
              return;
            }

            const summary = checkovResults.summary || {};
            const passed = summary.passed || 0;
            const failed = summary.failed || 0;
            const skipped = summary.skipped || 0;

            let criticalCount = 0;
            let highCount = 0;
            let mediumCount = 0;
            let lowCount = 0;
            let unknownCount = 0;

            const failedChecks = checkovResults.results?.failed_checks || [];

            console.log(`Total failed checks: ${failedChecks.length}`);

            if (failedChecks.length > 0) {
              console.log('Sample check structure:', JSON.stringify(failedChecks[0], null, 2));
            }

            const severityMap = {
              'CRITICAL': 'critical',
              'HIGH': 'high',
              'MEDIUM': 'medium',
              'LOW': 'low',
              'INFORMATIONAL': 'low',
              'INFO': 'low'
            };

            failedChecks.forEach((check, index) => {
              if (index < 3) {
                console.log(`Sample check ${index}:`, JSON.stringify({
                  check_id: check.check_id,
                  severity: check.severity,
                  check_class: check.check_class,
                  bc_check_id: check.bc_check_id,
                  guideline: check.guideline ? 'present' : 'absent'
                }, null, 2));
              }

              let severity = '';

              if (check.severity) {
                severity = check.severity;
              } else if (check.check_class) {
                const match = check.check_class.match(/(CRITICAL|HIGH|MEDIUM|LOW)/i);
                if (match) {
                  severity = match[1];
                }
              }

              if (check.guideline) {
                const guidelineMatch = check.guideline.match(/Severity:\s*(CRITICAL|HIGH|MEDIUM|LOW)/i);
                if (guidelineMatch) {
                  severity = guidelineMatch[1];
                }
              }

              if (!severity && check.bc_check_id) {
                severity = 'MEDIUM';
              }

              if (!severity) {
                severity = 'LOW';
              }

              const severityLower = severityMap[severity.toUpperCase()] || severity.toLowerCase();

              if (severityLower === 'critical') {
                criticalCount++;
              } else if (severityLower === 'high') {
                highCount++;
              } else if (severityLower === 'medium') {
                mediumCount++;
              } else if (severityLower === 'low') {
                lowCount++;
              } else {
                unknownCount++;
                if (index < 5) {
                  console.log(`Unknown severity for check ${check.check_id}: "${severity}" (original: ${check.severity || 'none'})`);
                }
              }

              check.computed_severity = severityLower;
            });

            console.log(`Severity counts - Critical: ${criticalCount}, High: ${highCount}, Medium: ${mediumCount}, Low: ${lowCount}, Unknown: ${unknownCount}`);

            let comment = `## 🛡️ Checkov IaC Security Scan Results\n\n`;
            comment += `### Summary\n`;
            comment += `| Status | Count |\n`;
            comment += `|--------|-------|\n`;
            comment += `| ✅ Passed | ${passed} |\n`;
            comment += `| ❌ Failed | ${failed} |\n`;
            comment += `| ⏭️ Skipped | ${skipped} |\n\n`;

            comment += `### Findings by Severity\n`;
            comment += `| Severity | Count |\n`;
            comment += `|----------|-------|\n`;
            comment += `| 🔴 Critical | ${criticalCount} |\n`;
            comment += `| 🟠 High | ${highCount} |\n`;
            comment += `| 🟡 Medium | ${mediumCount} |\n`;
            comment += `| 🟢 Low | ${lowCount} |\n`;
            if (unknownCount > 0) {
              comment += `| ⚪ Unknown | ${unknownCount} |\n`;
            }
            comment += `\n`;

            if (criticalCount > 0 || highCount > 0) {
              comment += `### ⚠️ Critical & High Severity Issues\n\n`;

              const criticalAndHigh = failedChecks
                .filter(check => {
                  const severity = check.computed_severity || '';
                  return severity === 'critical' || severity === 'high';
                })
                .slice(0, 15);

              criticalAndHigh.forEach(check => {
                const severity = check.computed_severity === 'critical' ? '🔴 CRITICAL' : '🟠 HIGH';
                comment += `#### ${severity}: ${check.check_id}\n`;
                comment += `**File:** \`${check.file_path}:${check.file_line_range?.[0] || 'N/A'}\`\n`;
                comment += `**Resource:** \`${check.resource}\`\n`;
                comment += `**Description:** ${check.check_name}\n`;
                if (check.guideline) {
                  const shortGuideline = check.guideline.length > 200
                    ? check.guideline.substring(0, 200) + '...'
                    : check.guideline;
                  comment += `**Guideline:** ${shortGuideline}\n`;
                }
                comment += `\n`;
              });

              const criticalHighCount = criticalCount + highCount;
              if (criticalHighCount > 15) {
                comment += `\n_... and ${criticalHighCount - 15} more critical/high severity issues. Check the Security tab for full details._\n\n`;
              }
            }

            if (mediumCount > 0 || lowCount > 0) {
              comment += `### ℹ️ Medium & Low Severity Issues\n`;
              comment += `Found ${mediumCount} medium and ${lowCount} low severity issues. These won't block the merge but should be reviewed.\n\n`;
            }

            if (criticalCount > 0 || highCount > 0) {
              comment += `\n---\n`;
              comment += `❌ **Build Status:** FAILED - ${criticalCount} Critical and ${highCount} High severity issues found!\n`;
              comment += `\n💡 **Next Steps:** Fix the critical and high severity issues above before merging.\n`;
            } else if (failed > 0) {
              comment += `\n---\n`;
              comment += `⚠️ **Build Status:** PASSED with warnings - Only low/medium severity issues found (${mediumCount} medium, ${lowCount} low).\n`;
              comment += `\n💡 Consider fixing these issues to improve security posture.\n`;
            } else {
              comment += `\n---\n`;
              comment += `✅ **Build Status:** PASSED - No security issues found!\n`;
            }

            comment += `\n📊 View detailed results in the [Security tab](https://github.com/${{ github.repository }}/security/code-scanning)`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('🛡️ Checkov IaC Security Scan Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }