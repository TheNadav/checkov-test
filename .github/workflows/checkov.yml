name: Checkov IaC Scan

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: read
  security-events: write
  actions: read
  pull-requests: write

jobs:
  checkov-scan:
    name: Checkov Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Checkov with severity filtering
        id: checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: .
          output_format: json,sarif
          output_file_path: console,results
          soft_fail: false
          hard_fail_on: HIGH,CRITICAL
          quiet: true
        continue-on-error: true

      - name: List output files for debugging
        if: always()
        run: |
          echo "=== Listing current directory ==="
          ls -la
          echo "=== Looking for Checkov results files ==="
          find . -name "*checkov*" -o -name "results*" -o -name "*.json" -o -name "*.sarif" | head -20
          echo "=== Checking results directory ==="
          if [ -d "results" ]; then
            ls -la results/
            echo "=== Content of JSON file if exists ==="
            if [ -f "results/results_json.json" ]; then
              head -100 results/results_json.json
            fi
          fi

      - name: Upload SARIF to Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results/results_sarif.sarif

      - name: Generate PR Comment
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            let checkovResults;
            try {
              const fileContent = fs.readFileSync('results/results_json.json', 'utf8');
              console.log('Raw Checkov JSON file content (first 500 chars):', fileContent.substring(0, 500));
              checkovResults = JSON.parse(fileContent);
              console.log('Parsed Checkov results (first 1000 chars):', JSON.stringify(checkovResults, null, 2).substring(0, 1000));
            } catch (error) {
              console.log('Error reading Checkov results:', error.message);
              console.log('Attempted to read: results/results_json.json');

              try {
                const altPath = 'checkov-results.json';
                console.log(`Trying alternative path: ${altPath}`);
                const altContent = fs.readFileSync(altPath, 'utf8');
                checkovResults = JSON.parse(altContent);
                console.log('Successfully read from alternative path');
              } catch (altError) {
                console.log('Alternative path also failed:', altError.message);
                return;
              }
            }

            const summary = checkovResults.summary || {};
            const passed = summary.passed || 0;
            const failed = summary.failed || 0;
            const skipped = summary.skipped || 0;

            let criticalCount = 0;
            let highCount = 0;
            let mediumCount = 0;
            let lowCount = 0;
            let unknownCount = 0;

            const failedChecks = checkovResults.results?.failed_checks || [];

            console.log(`Total failed checks: ${failedChecks.length}`);

            failedChecks.forEach(check => {
              const checkType = check.check_type || '';
              const checkClass = check.check_class || '';
              const severity = check.severity || '';

              console.log(`Check: ${check.check_id}, Severity: ${severity}, Check Class: ${checkClass}`);

              const severityLower = severity.toLowerCase();

              if (severityLower === 'critical') {
                criticalCount++;
              } else if (severityLower === 'high') {
                highCount++;
              } else if (severityLower === 'medium') {
                mediumCount++;
              } else if (severityLower === 'low') {
                lowCount++;
              } else {
                unknownCount++;
                console.log(`Unknown severity for check ${check.check_id}: "${severity}"`);
              }
            });

            console.log(`Severity counts - Critical: ${criticalCount}, High: ${highCount}, Medium: ${mediumCount}, Low: ${lowCount}, Unknown: ${unknownCount}`);

            let comment = `## üõ°Ô∏è Checkov IaC Security Scan Results\n\n`;
            comment += `### Summary\n`;
            comment += `| Status | Count |\n`;
            comment += `|--------|-------|\n`;
            comment += `| ‚úÖ Passed | ${passed} |\n`;
            comment += `| ‚ùå Failed | ${failed} |\n`;
            comment += `| ‚è≠Ô∏è Skipped | ${skipped} |\n\n`;

            comment += `### Findings by Severity\n`;
            comment += `| Severity | Count |\n`;
            comment += `|----------|-------|\n`;
            comment += `| üî¥ Critical | ${criticalCount} |\n`;
            comment += `| üü† High | ${highCount} |\n`;
            comment += `| üü° Medium | ${mediumCount} |\n`;
            comment += `| üü¢ Low | ${lowCount} |\n`;
            if (unknownCount > 0) {
              comment += `| ‚ö™ Unknown | ${unknownCount} |\n`;
            }
            comment += `\n`;

            if (criticalCount > 0 || highCount > 0) {
              comment += `### ‚ö†Ô∏è Critical & High Severity Issues\n\n`;

              const criticalAndHigh = failedChecks
                .filter(check => {
                  const severity = (check.severity || '').toLowerCase();
                  return severity === 'critical' || severity === 'high';
                })
                .slice(0, 15);

              criticalAndHigh.forEach(check => {
                const severity = (check.severity || '').toLowerCase() === 'critical' ? 'üî¥ CRITICAL' : 'üü† HIGH';
                comment += `#### ${severity}: ${check.check_id}\n`;
                comment += `**File:** \`${check.file_path}:${check.file_line_range?.[0] || 'N/A'}\`\n`;
                comment += `**Resource:** \`${check.resource}\`\n`;
                comment += `**Description:** ${check.check_name}\n`;
                if (check.guideline) {
                  comment += `**Guideline:** ${check.guideline}\n`;
                }
                comment += `\n`;
              });

              const criticalHighCount = criticalCount + highCount;
              if (criticalHighCount > 15) {
                comment += `\n_... and ${criticalHighCount - 15} more critical/high severity issues. Check the Security tab for full details._\n\n`;
              }
            }

            if (mediumCount > 0 || lowCount > 0) {
              comment += `### ‚ÑπÔ∏è Medium & Low Severity Issues\n`;
              comment += `Found ${mediumCount} medium and ${lowCount} low severity issues. These won't block the merge but should be reviewed.\n\n`;
            }

            if (criticalCount > 0 || highCount > 0) {
              comment += `\n---\n`;
              comment += `‚ùå **Build Status:** FAILED - ${criticalCount} Critical and ${highCount} High severity issues found!\n`;
              comment += `\nüí° **Next Steps:** Fix the critical and high severity issues above before merging.\n`;
            } else if (failed > 0) {
              comment += `\n---\n`;
              comment += `‚ö†Ô∏è **Build Status:** PASSED with warnings - Only low/medium severity issues found (${mediumCount} medium, ${lowCount} low).\n`;
              comment += `\nüí° Consider fixing these issues to improve security posture.\n`;
            } else {
              comment += `\n---\n`;
              comment += `‚úÖ **Build Status:** PASSED - No security issues found!\n`;
            }

            comment += `\nüìä View detailed results in the [Security tab](https://github.com/${{ github.repository }}/security/code-scanning)`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üõ°Ô∏è Checkov IaC Security Scan Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }